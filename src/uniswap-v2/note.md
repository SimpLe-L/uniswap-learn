## uniswap V2
uniswap v2主要分为两大模块： core 和 periphery。相较于v1版本，v2有很多优化点：
(1). 支持ERC20代币/ERC20代币交易对
  v1中实际上只支持token -- eth之间的兑换，改动后这减少了流动性提供者的成本，两个代币直接相关总比用以太过渡损失要小。并且以太过渡要支付两次手续费，遭受两次滑点。
(2). 价格预言
  uniswap v2通过测算和记录前一个区块最后的价格。v1作为链上价格预言是不安全的，因为它非常容易被操纵。在一个block的开头大量卖出某种资产A从而影响价格，在该block的中间根据这个大幅波动的价格进行其它合约的其它操作(非uniswap交易对合约)，在该block的最后再买入相同数量的资产A使价格回到正常水平。
(3). 价格计算精度
  使用简单的二进制定点数格式编码和控制价格。价格存储为UQ112.112格式，意思是在小数点的任意一边都有112位精度，无符号。 
(4). Flash Swaps
  相当于闪电贷，V2允许先接收和使用资产再支付，只需要他们在一个原子操作里。swap函数里可以调用户指定的回调合约，转出用户请求的代币并保持不变，回调完成后合约检查新余额，是否不变。（会收取0.3%的手续费）
(5). 协议手续费
  v2可以选择是否打开0.05%的协议手续费，如果打开，手续费会被发送给工厂合约中指定的feeTo地址。将0.3%的交易手续里的1/6发送给feeto.这个费用只有在增加/减小流动性时才会做相应计算。
(6). 资金池份额的元交易
  用户可以签名授权他们资金池份额转账，而不用他们的地址进行链上的转账。也就是说其他人可以拿到授权后直接用用户的名义签名交易、转账执行其他操作。
(7). 手续费调整
  v1中强制确保：(x1-0.003X-in)*y1=X0*Y0。V2的flash中，可能存在用户token1和token2各还一点，保证还回同样的资产。所以此时的x-in和y-in可能都不为0，那么就需要换一套计算方式： (x1-0.003X-in)*(y1-0.003Y-in)=X0*Y0
(8). 确定的交易对地址
  v1是create构造代币地址的，v2用create2构造交易对地址
(9). WETH
  ETH的转账接口和ERC20交互用的标准接口不同，因为Uniswap v2支持任意ERC20交易对，它现在不再支持无包装的ETH。

## uniswap V2 CORE
1. uniswapV2Factory：主要用来创建Pair（交易池）；协议手续费相关实现也在此合约中实现
--核心函数：createPair
检查输入的两种token是否一样，对两种token进行一个简单的排序，检查小的地址是否为0地址，检查这两种token的交易对是否已经存在。获取模板合约UniswapV2Pair的字节码，并用两种token的地址生成salt，通过create2构造出Pair交易对的地址并记录

2. uniswapV2ERC20
常规mint， burn, approve, transfer, transferFrom, permit(用户实现验证与授权)等

3. uniswapV2Pair: 交易对合约的核心逻辑
--心函数：mint，生成流动性代币
拿到reserve0和reserve1，算出目前的两种token的余额，将他们与reserve相减算出增加的余额。生成流动性代币，如果是初次提供流动性，会生成MINIMUM_LIQUIDITY个代币给0地址（对应上面第10点初始化流动性供给），再根据恒定乘积公式中积的平方根来计算流动性：S-mint=根号(X-deposit*Y-deposit)；如果不是初次提供流动性，根据两种token的增加比例计算并取两者间最小的。流动性=存入的token数量/token之前的总数 * 总的流动性，最后更新reserve

--核心函数：burn，销毁流动性将token归还流动性提供者
拿到reserve0和reserve1，拿到合约实际两种token的余额，以及合约的流动性代币总数（一般情况下，合约是没有流动性代币的，因为mint是直接mint给流动性提供者，但是burn之前需要把流动性代币转给合约，于是合约就有流动性代币了），生成流动性代币，计算返回的token0和token1的数量，按照比例计算：要燃烧的流动性代币/总流动性代币数量*目前token的数量，燃烧代币之后将token0和token1转给流动性提供者，更新reserve

--核心函数：swap，用于交易对中资产的交换
1.传入的参数amount0Out，amount1Out,to以及data分别是要购买的token0的数量，token1的数量，接收者的地址，接收后执行回调传递数据。
2.先判断要购买的token数量是否大于0，接着使用getReserves()获取当前库存的交易对资产数量，并判断购买的token是否小于reserve的值。
3.如果amount0Out大于0，说明要购买token0，则将token0转给 to；如果amount1Out大于0，则说明要购买token1，则将token1转给to
4.调用合约的uniswapV2Call回调函数将data传递过去，普通交易调用这个data为空
5.获取此时交易对资产的余额
6.amount0In通过当前余额和库存余额比较可得出汇入流动性池的资产数量
7.更新恒定乘积公式，并且新的值要大于等于原来的值。

https://blog.csdn.net/weixin_39430411/article/details/108965855

## uniswap V2 Periphery
外围主要就是router合约，封装了最常用的几个交易接口。其他合约还包括数学计算，输入输出数量就算等功能。

1. UniswapV2Router02
--核心函数：addLiquidity
添加流动性。
检查交易对是否存在，不存在就创建
拿到tokenA和tokenB的reserve
如果是第一次增加流动性就直接将注入的资产全部转换为流动性
如果不是第一次，根据池子的比例计算。根据传入的A的数量算出需要传入的B的数量。
如果需要的B小于传入的B，那么流动性就是用输入的A数量和需要传入的B的数量
如果需要的B大于传入的B，那么流动性就是用输入的B数量和需要传入的A的数量

--核心函数：removeLiquidity
移除流动性

--核心函数：_swap
token交换
